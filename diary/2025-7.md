# 7月の目標


## 7/1

### 振り返り
- 機能仕様について、追加された関数について言及した方がいいかを確認 → 必要なし
- 機能仕様の更新

- Fluent Pythonを読み進める
  - `@property`デコレータはその関数における特殊メソッドをオーバーライドして、関数の呼び出し方によって返す関数を変更する
  - ディスクリプタについて軽く理解

```py
# 具体例

class Person:
    def __init__(self, name):
        self._name = name

    @property # getter
    def name(self):
        return self._name

    @name.setter # setter
    def name(self, value):
        if not value:
            raise ValueError("名前は空にできません")
        self._name = value

    @name.deleter # deleter
    def name(self):
        print("名前の削除")
        del self._name

taro = Person("太郎") # 値の取得を行う。getterが呼び出される
print(taro.name) 
# 太郎
taro.name = "山田太郎" # 値の設定を行う。setterが呼び出される
print(taro.name)
# 山田太郎
del taro.name # 値の削除を行う。deleterが呼び出される
# 名前の削除
print(taro.name) 
# AttributeError: 'Person' object has no attribute '_name'
```

- RAG構築の本を進める
  - リソースの設定ができた
  - 実際にリクエストを送ってみたが、リソースがないと出ている。
  - タイポはないはずだがよくわからない
  - .pyからリクエスト送ったら返ってきた
    - zshの問題か、curlの書き方の問題？？

## 7/2

### 振り返り
- 納品物の確認
  - Wikiのクローンがうまくいかなかった
  - 新しいリポジトリでブランチを明示的に設定したら解決した
  - `git clone --branch master ssh://git@hogehoge.com:2222/xxx/yyy/zzz.wiki.git`

- Fluent Pythonを読み進める
  - いったん一通りさらえたので、復習目的ではじめから斜め読みしていく
  - リソースは他に使っていく

- RAG構築の本を進める
  - 本実装の検索部分のコンポーネントはAzure AI Searchを使う
  - 複数のドキュメントが格納されているインデックスを使って情報を管理する
  - それぞれのドキュメントは特定のスキーマに基づいて構成されている
  - 例えば、主キー、content, category, rating
  - データの持ち方
    - レプリカ：インデックスの複製をいくつか持っておくことで同時に多くの検索リクエストを処理できる（負荷分散、高可用性）
    - パーティション：インデックスを複数の部分に分割する仕組み。複数サーバーで並行して処理できる

## 7/3

### 振り返り
- 次回追加機能のロジック確認

- Fluent Python復習

- RAG構築コーディング

- Reactチュートリアル進める

## 7/4

### 振り返り
- MRの作成＋レビュー依頼
  - リモートの変更を取り込みrebaseしpush完了
  - flake8は`--ignore=E501`をつけてチェックする。（デフォルトのリストを上書きするので挙動が少し変わる）

- FluentPython復習

- RAG構築続き
  - 実際にリソースを立てて、動かしてみる

- Reactチュートリアル進める

## 7/7

### 振り返り
- RAG構築続き
  - なんとか接続完了した
    - APIのバージョンは、モデルのバージョンと異なる
  - RAGではアプリ開発と評価方法が少し違う
    - ユーザーからの質問に対してどれだけ正確で信頼性のある回答を返せるかが大事
    - 人手による評価、LLMによる評価がある
    - Prompt FlowというRAGの評価ツールがある
  - RAGの評価指標
    - 「ユーザーの質問」「コンテキスト」「回答」「Ground Truth」が大事
    - 回答とGround Truthの比較
      - 差異がある場合は、RAGの一連の流れ、そもそもユーザーの質問が適切でない、Retrieverが適切に情報を取得できていない、Generatorが正確な回答が生成できていない可能性がある
    - コンテキストとユーザーの質問の整合性
      - 適切に情報を検索できているか？Retrieverの調整が必要
    - 回答が、コンテキストに基づいて生成されたか
      - Generatorが適切な回答を生成するように調整が必要
  - Prompt Flowによる評価指標
    - 根拠性：「回答」「コンテキスト」
      - Generatorが生成した回答が、コンテキスト内の事実や現実にどれだけ基づいているかを評価
    - 類似性：「回答」「Graund Truth」
      - LLMを使ってGeneratorが生成した回答がGround Truthにどれだけ類似しているか測定
    - 関連性：「質問」「回答」
      - モデルの回答が、質問に対してどれだけ適切に関連しているか
    - コヒーレンス、流暢性：「回答」
      - 回答全体の文法的な正しさや自然さを評価
    - 実際に出力したcsvファイルをPrompt Flowを使って評価した
  - RAGの改善方法
    - セマンティックチャンキング：まずは小さなフレーズ単位で分割し埋め込みを行う、類似度が高ければ結合する。
      - 意味のまとまりがある分のグループがチャンクとして形成される。内容に応じた可変長のチャンクができる
    - HyDE(Hypothetical Document Embedding)：クエリから仮の回答を作ってそれとドキュメントの類似度を比較する
      - クエリとドキュメントを比較すると言い回しや構成が違うので意図しないコンテキストになる可能性。クエリを一旦仮のドキュメントにすることで適正に比較できる！

## 7/8 

### 振り返り
- RAG構築つづき
  - ハイブリッド検索の実装完了
    - ベクトル検索やキーワード検索を組み合わせることで情報の検索精度を上げれる
  - 他にも改善手法はいろいろある
    - 基本的にはクライアントを作ってクエリを処理することが多い

- Fluent Python復習
  - `setdefault`, `defaultdict`使い方

- CI/CDガイドに入った
  - GitHub CLIの導入


## 7/9

### 振り返り
- CI/CDガイド進める
  - GitHub Actionsはワークフロー、イベント、ランナー、ジョブ、ステップで構成される
  - 1つのYAMLファイルにワークフローは一つ、ワークフローは指定したイベントで起動しジョブを実行する
  - `P18`のシェルコマンドの実行、アクションの呼び出しは要確認
  - workflowは`on: workflow_dispatch`を指定すれば手動実行可能
    - `gh workflow run manual.yml -f greeting=goodby`でCLI実行もできる
    - 他にも、`on: schedule`を指定すれば時間指定も可能（ずれるので、多少ゆるいタスクに向いている）
  - もしなんらかの障害でワークフローが失敗しても、ジョブ単位で再実行できる
    - もし削除したくないけど、無効化したい時は`Disable workflow`を設定
  - コンテキストで実行時の情報などにアクセスできる
    - github, runnerのコンテキスト
    - 環境変数の参照もできる
      - 直接コンテキストをシェルコマンドに埋め込むのはアンチパターン
      - 中間環境変数を経由して渡す。＋環境変数は全てダブルクォートで囲む
    - 環境変数は単一のワークフローのみ有効 → 複数使いたい時はVariablesに登録する
      - `${{ vars.USERNAME }}`のように参照できる（中間環境変数に登録すべき）
    - パスワードなど機密情報もSeacretsで設定できる
      - `${{ secrets.PATHWORD }}`で設定できる
      - ただし、運用上はそもそもログ出力しない方がいい！！
    - コンテキスト参照の特殊記法としてオブジェクトフィルターが使える
      - 配列やオブジェクトから指定したプロパティのみ取り出し、配列を生成する
      - `${{ github.event.*.html_url }}`：関数と組み合わせでよく使われる！
      - このブランチは対象から外したいなどもできる！
    - JSON操作もできる
    - 文字列リテラルは基本的にシングルクォートを使った方がいい

- クライアント先にMRを作成した。
  - 完了報告もできたので次の機能について調査開始


## 7/10 

### 振り返り
- 次の機能の注意点をIssueで整理

- CI/CDガイド進める
  - テストワークフローは次で構成される。（言語によらない）
    1. チェックアウトステップ \
      `- uses: actions/checkout@v4`でソースコードを取得する
    2. 言語セットアップステップ \
      セットアップアクションを呼び出す
    3. テストステップ  
      テストを実行（ツールによって異なる）
  - フィルターやアクティビティタイプでワークフローの制御ができる
  - 常にタイムアウトとデフォルトのシェルを設定しておく（パイプエラーを拾える）
  - Concurrencyを使って多重起動の抑制や自動キャンセルができる
  - CIの黄金率は「クリーンに保つ」「高速に実行する」「ノイズを減らす」


## 7/11

### 振り返り
- 機能についての疑問点解消
- 機能差分について整理

- CI/CDガイド進める
  - ワークフローの設計について
  - 必要な情報をタイムリーに出せるのは大事
    - ロギング、レポーティング、チャット通知を活用
  - ジョブ管理で複数のシチュエーションに対応
    - ジョブを並行、逐次実行する、マトリックスを使って効率した実装、異なる環境をEnvironmentsで定義
  - ワークフローのライフサイクルを超えてデータを扱う時のデータ管理方法
    - キャッシュ（複数のワークフローでデータを再利用）、アーティファクト（実行後もデータを保管できる）
  - アクションを自分で定義できる。（Composite Action）
    - メタデータファイルを使って、入出力I/Oとメインロジックを記述する


## 7/14

### 振り返り
- テストケースの洗い出し
- 詳細設計、テスト設計の大枠確認

- CI/CDガイド進める
  - クリーンなリポジトリの維持
    - ブランチの保護：ブランチプロテクションツール
    - クレデンシャルの混入防止
      - スキャン、プッシュプロテクションがある
      - クレデンシャル検出時は、現在のクレデンシャルを無効化または削除し、新しいクレデンシャルを作成する

## 7/15

### 振り返り
- 追加機能の動作確認（出力ファイルの妥当性）→ 完了
- 詳細設計をまとめる → 完了
- デザインパターンを勉強しておきたい
  - Zennに[いい記事](https://zenn.dev/mossan_hoshi/books/84487f17784b44/viewer/0_front_matter)があった


- CI/CDガイド進める
  - 依存関係を放置すると、何もしていないのにソフトウェアが壊れることがある
  - 依存関係を解消するためにDependabotを活用するとよい
    - 自動アップデートや自動マージワークフローを実装できる
  - バージョンアップ時は影響範囲の確認は必須
    - 破壊的更新の頻度、ソフトウェアの依存度合い、自動テストの充実度などで変わる
    - パッチバージョンのみ、開発者向けのみ自動マージなど一部の自動化も恩恵あり


## 7/16

### 振り返り
- 詳細設計を提出 → 完了
  - 値をブロードキャストして再代入の処理をしていた
  - あとから参照した時に見つけにくくなるため、一時的に別の変数に代入する処理に変更

- CI/CDガイド進める
  - ソフトウェアのリリースには「ビルド」「バージョニング」「アナウンス」がある
  - よくセマンティックバージョニングが使われる（X.Y.Z）
    - メジャーバージョン：後方互換性がない大きな変更（X）
    - マイナーバージョン：後方互換性がある機能追加や改善（Y）
    - パッチバージョン：後方互換性があり、機能追加のない修正（Z）
    - 後方互換性：新しく開発された製品やシステムが、それよりも古い（既存の）製品やデータ、規格などを問題なく扱える性質
    - 大まかな影響範囲がわかるメリットもあるが、作成者の力量により裏切られることもある
  - リリースノートを使って周知させる
    - 破壊的な変更「Breaking Changes」、新機能の追加「New Features」、既存機能の改善「Enhancement」、不具合修正「Bug Fixes」
    - GitHub Releasesでリリースノートの作成とアップロードの自動化ができる
  - Gitタグは便利だが、変更削除がかんたんにできるので保護しておくと良い

