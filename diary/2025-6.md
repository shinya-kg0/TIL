# 6月の目標



## 6/2

### 振り返り
- フロントエンドの初期セットアップ
  - Dockerfile, compose.ymlを更新
- 納品作業練習
  - 次は自分でできるように、メモをとっておく
  - 確認系のタスクはクリーンな環境が推奨される（新しくクローンする）
  - `git tag`の使い方を理解（どの時点のリリースかを確認できる）  
    → [参考記事](https://qiita.com/growsic/items/ed67e03fda5ab7ef9d08)
  - linuxコマンドを実際に使えるようになっていて嬉しかった。（findgrep）
  - 納品されてお金になるので、ドキュメントの作成も大事な仕事の一つ
- ハードウェアとソフトウェアで値の認識の仕方が異なる
  - ハードウェアはshapeが1のものは無視される
  - flattenのような挙動、メモリ上に数値が並べられる
- サブクラス化の要望あり
  - メソッド一つに対して、新しくインスタンスを作らないといけないので避けたい

## 6/3

### 振り返り
- 納品作業デモ続き
  - 変更箇所を特定するには、コミット履歴を見てあたりをつけて個別に見ていくしかない

- 命名をするときは、そのオブジェクトがどんな情報を持っているか、何に使われているかを含める
  - コメントを残したくなる内容を名前に含める
  - コード内で雛形を統一して、認知的負荷を避ける

- ドキュメントにはタイムスタンプをつける
  - タイムスタンプの使い方はlinux > fundamentals.md
  - 環境変数を一時的に使う方法（設定から削除まで）
  - ファイルのタイムスタンプを確認する方法  
    `ls -l --time-style=full-iso`

- Wordの修正作業が大変
  - コピペしないといけない文章の体裁を整えるのにWordのスタイルを適応する必要がある
  - 慣れていけば問題なさそうだが、数ヶ月に一回しか使わない、、、
- VBAのプログラムがバージョン違いで中断する。
  - 再度実行したら動作する。（謎）

## 6/4

### 振り返り
- 納品作業でWordのスタイルの適応の流れを学んだ
- VBAのデバックをした
  - なぜか一行追加しただけで解決した。（貼り付けの問題だったみたい）
- `obj.method = types.MethodType(func, obj)`でクラスにメソッドを追加できる
- Pythonの関数もクラスもオブジェクト
  - メソッドもクラスのattrみたいなもので書き換え可能
- 抽象クラスの使い方の入り口
  - ABCクラスの継承、@abstractmethodの使い方

## 6/5 

### 振り返り
- 修正点の要件を整理する。
  - 特定のメソッド用のサブクラス化
  - パラメタの転置処理
    - `np.transpose`で軸の順番を変えることができる
    - 軸の順番を変えるのは、同じ塊をどの軸から見るかを変更している（メモリの配置を変えている）だけなので、中身は変わっていない
    - 転置処理については、修正してテストのPASSを確認できた。

- 修正要件の整理から設計までの流れをまとめた。（Notionを確認）
- プログラマー脳の続き
  - コードの臭い
  - 問題解決とは？

- Reactでフロント部分の作成（時間がかかりそう）

## 6/6 

### 振り返り
- プログラマー脳続き
  - 複雑な問題を解くために（長期記憶の掘り下げ）
- メインプロダクトの共通部分の処理を実装レベルで理解していく
  - 全体の流れの理解
  - ログ管理なども
  - 各メソッドの役割など

- `__repr__()`：このクラスはどんな要素で表現できるかを公式に設定できる
- `__call__()`：クラスインスタンス自体を関数のように呼び出せる。柔軟性○
- `collections`：基本的なデータ型（コンテナ）以外の特殊なデータ型の集まり（namedtaple, defaultdictなど）

- Pythonの理解が深まっているのか、どこを見たらいいかや、どういう構成になっているのかをイメージできるようになっている

## 6/9

### 振り返り
- プログラマー脳続き
  - コードを書く活動には5種類あり、それぞれ違う負荷がかかる。
  - どんな作業にどんな負荷がかかっているか理解して、対策を打てば効率が良い
  - 大きなコードの特性を表す指標がある
  - コードのライフサイクルによって重視する特性が変わる

- メインプロダクトの共通部分の処理の掘り下げ
  - メイン処理の中で、それぞれのモジュールが呼ばれていく流れ
  - メイン処理の流れは理解できた。
  - `sys`ライブラリの使い方
    - `sys.argv`：コマンドライン引数の制御
    - `sys.exit()`：プログラムの終了
    - `sys.path`：パスの制御（`.append`でパスの追加）
  - `kwargs`の使い方
    - 設定などの情報を辞書で持っておいて、必要なときに参照する
  - ファイル操作について（読み書き）
  - `json`モジュールの使い方（読み出し、書き出し）
  
## 6/10

### 振り返り
- プログラマー脳続き
  - 初学者と熟練者の違い
  - オンボーディングの注意

- 共通部分の処理の掘り下げ
  - PDBを使って、動的にコードを解析できている。
  - 拡張系のモジュールについて確認中。
- 開発している機能にエラー関数が追加されたので動きを確認する。
  - モンキーパッチを使えば対応できそう。（要調査）

## 6/11

### 振り返り
- モンキーパッチの使い方を調べる。
  - テストコードに適応する
- サーバー内にあるローカルファイルのバックアップをとる（特にsshキー）

項目     |	monkeypatch.setattr()	| testfixtures.replace
----------|---|---
提供ライブラリ	| pytest	| testfixtures (サードパーティ)
依存関係 | 	pytest 環境が必要	| testfixtures ライブラリのインストールが必要
利用形式	| pytest フィクスチャとして引数で受け取る	| with ステートメント (コンテキストマネージャー)
スコープの明示性	| 関数スコープで自動ロールバックされるが、コード上での適用範囲の明示性は replace ほどではない |	with ブロック内という明確な適用範囲
汎用性	| pytest 専用	| unittest など他の環境でも利用可能
API	| setattr(), setenv() など個別のメソッド	| replace() が中心だが、testfixtures 全体で豊富な機能
自動ロールバック | 	テスト関数終了時	| with ブロック終了時

- プログラマー脳を読み切る
- オンボーディング資料を充実できないか検討する
- zipコマンドの使い方
  - zipで固める：`zip -r output.zip target_dir/`
  - ファイルサイズをチェック：`ls -lh output.zip`
  - zipの中身をチェック：`unzip -l output.zip`
  - zipファイルを解凍：`unzip output.zip -d extracted_files/`

## 6/12

### 振り返り
- 共通関数のコード読み
  - ソースコードが大きすぎるので計画的に読んでいく
  - 完璧じゃなくても大丈夫
- 次の機能のテストコードを作成
- 次のタスクのすり合わせ

## 6/13

### 振り返り
- 追加されたエラーチェック関数の挙動をまとめる
- 共通関数のコード読み
  - 何となく、配置や大きな構造を捉え始めている気がする


## 6/16

### 振り返り
- エラーチェック関数の挙動をまとめ中
  - 条件判定に矛盾があったので確認

- 客先との確認完了
  - 修正される予定だが、現状の動きでは想定はされてない動きをするのでその部分もメモしておく

- 伝わるコードレビューを読み始めた
  - レビュアーとレビュイーの信頼関係が必要
  - お互いの意図が掴めないとまずい
  - 問題 vs 私たちの構図を作る
  - 推測ではなく確認を
  - 客観的な根拠を示す

- Fluent Pythonを読む
  - 第7章の関数デコレータとクロージャについて
    - 実行タイミング、変数スコープ、自由変数のバインディング
    - 標準ライブラリのデコレータ（`functools.lru_cache`, `functools.singledispatch`）
    - 再起的な処理のキャッシュを効率化や型によって処理が変わるジェネリック関数を作れる
    - デコレータの多重化やパラメータ持ちのデコレータも作れる
    - __call__を実装したクラスにデコレータを組み合わせるのが最適とされている。
  - 第8章：オブジェクト参照、可変性、リサイクル
    - 変数はラベルであり、箱ではない
    - 同一性と等価性は違う
    - `is`は変数が`None`にバインドされていないかチェックするときによく使う（高速に処理可能）