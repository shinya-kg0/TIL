# データ取り込み、ストリーム処理ツール比較

| **カテゴリ** | **ツール名** | **管理元 / 主な提供形態** | **特徴・メリット** | **抑えておきたいポイント / 課題** |
| --- | --- | --- | --- | --- |
| **メッセージブローカー** (運搬・蓄積) | **Apache Kafka** | OSS / Confluent / 各クラウド | **業界標準。** 圧倒的なスループットとエコシステムの広さ。高い耐久性を持つ。 | 運用負荷（ZooKeeperや管理）が高い。スケール時のパーティション再配置が複雑。 |
|  | **Amazon Kinesis** (Data Streams) | AWS (マネージド) | **AWS特化。** 設定が簡単で、他のAWSサービス（Lambda, S3等）との親和性が極めて高い。 | シャード単位の管理が必要。AWS以外での利用は一般的ではない。 |
|  | **Google Cloud Pub/Sub** | GCP (マネージド) | **完全サーバーレス。** グローバルなスケーラビリティ。シャード管理不要で導入が最も容易。 | 順序保証の厳密な管理には設定が必要。GCP外からの利用はネットワークコストに注意。 |
|  | **Apache Pulsar** | OSS / StreamNative | **次世代型。** ストレージと計算層が分離されており、柔軟な拡張が可能。マルチテナント対応。 | Kafkaに比べると学習リソースやコミュニティがまだ成長途上。 |
| **処理エンジン** (加工・分析) | **Apache Flink** | OSS / 各クラウド | **真のリアルタイム処理。** 低遅延かつ「Exactly-once（正確に1回）」の強力な整合性保証。 | 学習曲線が急。複雑なステートフル処理に向くが、運用の難易度は高い。 |
|  | **Apache Spark** (Streaming) | OSS / Databricks | **統一エンジン。** バッチ処理と共通のコードで書ける。ML（機械学習）連携が非常に強力。 | 基本はマイクロバッチ方式（数秒単位）のため、ミリ秒単位の超低遅延には不向き。 |
|  | **Google Cloud Dataflow** | GCP (Apache Beam) | **運用の自動化。** リソースの自動スケールが優秀。バッチとストリームを同じモデルで扱える。 | Google Cloud (Apache Beam) への依存度が強くなる。デバッグがやや難しい。 |


-  イメージで理解する：アパート vs 一戸建て
    - マルチテナント（アパート）:
      - 1つの建物（システム）の中に、たくさんの部屋（テナント）があります。入り口やエレベーター、水道などのインフラは共有しますが、各部屋の鍵は別々で、プライバシーは守られています。

    - シングルテナント（一戸建て）:
      - 1つの建物（システム）を、1つの世帯（利用者）だけで独占して使います。自由度は高いですが、維持費や建設費が高くなります。

---


Apache Kafka（カフカ）を一言でいうと、  
**大量のデータを高速かつ安全にやり取りするための、超高性能なデジタル回転寿司**です。

データが流れてくるだけでなく、皿（データ）がベルトコンベアの上に一定期間残り続けるため、必要な人が好きなタイミングで取っていけるのが最大の特徴です。

---

### 1. Kafkaの登場人物（3つの役割）

Kafkaの世界は、主にこの3つの要素で動いています。

* **Producer（プロデューサー / 送り手）**
* データを生成してKafkaに投げ込む係。
* 例：スマホアプリのログ、センサーの数値、注文データなど。


* **Kafka Cluster（カフカ・クラスター / 運び手・保管庫）**
* データを受け取り、整理して保管する「回転寿司のレーン」そのもの。
* 複数のサーバー（ブローカー）で構成され、データが消えないようにコピーを作って守ります。


* **Consumer（コンシューマー / 受け取り手）**
* Kafkaからデータを取り出して処理する係。
* 例：リアルタイム分析エンジン、データベース保存用プログラムなど。



---

### 2. なぜ Kafka がこれほど使われているのか？（3つの強み）

従来の「メール」のような1対1の通信ではなく、Kafkaが選ばれるのには理由があります。

#### ① データの「一時保存」ができる（耐久性）

普通のメッセージツールは、渡したらデータが消えます。しかしKafkaは、**「過去7日間分は全部取っておく」**といった設定が可能です。

* **メリット**: もし受け取り側のシステムが故障して止まっても、復旧した後に「止まったところから再開」ができます。

#### ② 「送り手」と「受け取り手」を切り離せる（疎結合）

送り手は、受け取り側が誰か、今忙しいかどうかを気にする必要がありません。とりあえずKafkaに放り込めばOKです。

* **メリット**: システムの追加や変更がめちゃくちゃ楽になります。

#### ③ 圧倒的な「スピード」と「拡張性」

1秒間に数百万件というデータをさばけます。データ量が増えたら、サーバー（ブローカー）を横に並べて増やすだけで処理能力を上げられます。

---

### 3. Kafkaの構造：トピックとパーティション

Kafkaを理解する上で避けて通れないのが、この2つの言葉です。

* **Topic（トピック）**:
データの「カテゴリ（フォルダ）」です。「注文データ用」「アクセスログ用」のように分けます。
* **Partition（パーティション）**:
1つのトピックをさらに細分化した「レーン」です。1つのトピックを複数のレーンに分けることで、並列で処理できるようになり、爆速になります。


| **サービス** | **管理のイメージ** | **特徴** |
| --- | --- | --- |
| **自前 Kafka** | **DIY（日曜大工）** | サーバーの設置から設定まで全部自分。自由度は最高だが、壊れたら自力で直す。 |
| **Amazon MSK**
(Managed Streaming for Kafka) | **レンタカー** | Kafkaそのものを提供。メンテナンスはAWSがやるが、エンジンのサイズ（台数）は自分で選ぶ。 |
| **Amazon Kinesis** | **タクシー** | Kafkaに似た機能をAWS独自に構築。台数ではなく「シャード（車線数）」で容量を決める。 |
| **Google Cloud Pub/Sub** | **電車・バス** | **完全サーバーレス。** 容量の設定すら不要。乗った分（データ量）だけ払えば、勝手に巨大化する。 |


---

# 結果整合性と一貫性

**「ガチガチにルールを守る（一貫性）」**か、**「そのうち帳尻が合えばOKとする（結果整合性）」**かの違い



---

## 1. 一貫性（強整合性 / Strong Consistency）

**「いつ誰がどこから見ても、常に最新の同じデータが見える」**状態です。

* **仕組み:** データを書き込んだら、その書き込みが完全に終わるまで、次の読み込みを待たせます。あるいは、全てのコピー先にデータが書き込まれるまで「完了」としません。
* **例:** **銀行の残高。** Aさんが1万円振り込んだ直後にBさんが残高を確認して「まだ0円です」となったら困りますよね。
* **メリット:** データが常に正確。バグが起きにくい。
* **デメリット:** 全てのサーバーに確認をとる必要があるため、処理速度（レスポンス）が遅くなりがちで、システムが巨大になるとパンクしやすい。

## 2. 結果整合性（Eventual Consistency）

**「一時的に古いデータが見えるかもしれないけど、そのうち（最終的には）全員に正しいデータが届く」**状態です。

* **仕組み:** 「とりあえず手近なサーバーに書き込んだからOK！」と即座に返事をして、裏側でゆっくり他のサーバーにコピーを配ります。
* **例:** **SNSの「いいね」数やフォロワー数。** 誰かが「いいね」を押した瞬間、世界中のユーザーに「1」と表示される必要はありません。数秒後に全員が「1」を見ることができれば、実用上の問題はないからです。
* **メリット:** とにかく爆速。システムの一部が止まっていても動き続けられる（可用性が高い）。
* **デメリット:** 短い時間ですが、人によって見えているデータが違う「ズレ」が生じる。

---

### 比較まとめ

| 特徴 | 一貫性 (Strong) | 結果整合性 (Eventual) |
| --- | --- | --- |
| **データの正確さ** | 常に最新 | 一時的に古い場合がある |
| **スピード** | 遅め（慎重） | 爆速（楽観的） |
| **主な用途** | 決済、在庫管理、認証 | SNS、ログ収集、検索エンジン |
| **典型的なDB** | RDB (MySQL, PostgreSQL等) | NoSQL (DynamoDB, Cassandra等) |


## CAPの3つの要素

まず、それぞれの頭文字が何を意味するのか整理しましょう。

1. **C：Consistency（整合性）**
* どこからアクセスしても、常に**最新の同じデータ**が返ってくること。


2. **A：Availability（可用性）**
* システムが**常に動いている**こと。一部のサーバーが壊れても、エラーを返さず何らかの返答をすること。


3. **P：Partition Tolerance（分断耐性）**
* サーバー同士をつなぐ**ネットワークが途切れても**、システム全体が動き続けられること。



---

### なぜ「3つ同時」は無理なのか？

ここが一番のポイントですが、現代のクラウド環境において**「P（分断耐性）」は避けて通れません。** ネットワークはいつか必ず不安定になるからです。

すると、現実は**「CP」か「AP」か**の究極の二択を迫られることになります。

#### 例：ネットワークがブチッと切れたとき（Pが発生）

サーバーAとサーバーBが通信できなくなったとします。ここでデータが更新されました。

* **「C（整合性）」を守りたい場合（CP）**
サーバーAとBでデータの同期が取れないなら、中途半端なデータを返すわけにはいきません。そのため、システムを一時的に**止める（Aを捨てる）**しかありません。
* *用途：銀行振込、公的な手続きなど*


* **「A（可用性）」を守りたい場合（AP）**
「データが最新じゃないかもしれないけど、とりあえず返事をする」ことを優先します。サーバーAとBで違うデータを持っていても、**動き続ける（Cを捨てる）**ことを選びます。これが前回お話しした「結果整合性」の世界です。
* *用途：SNSのタイムライン、YouTubeのコメント欄など*


### CAPの組み合わせまとめ

| 組み合わせ | 特徴 | 実際によくある例 |
| --- | --- | --- |
| **CP** (C+P) | 正確さを最優先。エラーが出ることは許容する。 | RDB（強整合モード）、Redis、MongoDB |
| **AP** (A+P) | 止まらないことを最優先。データは「そのうち」揃えばいい。 | DynamoDB、Cassandra、CouchDB |
| **CA** (C+A) | ネットワーク分断が起きない前提。 | **分散システムではほぼ存在しません。**（単一サーバーのDBなど） |



---


# ブロックストレージとファイルストレージ

ストレージの選択は、データエンジニアリングにおいて「パフォーマンス」と「使いやすさ」のどちらを取るかという非常に重要な決断です。

一言でいうと、**「中身をバラバラの破片として扱う（ブロック）」**か、**「書類として整理して扱う（ファイル）」**かの違いです。

---

## 1. ブロックストレージ (Block Storage)

データを特定のサイズ（ブロック）に分割し、それぞれに固有の住所（アドレス）を割り当てて保存する方式です。

* **仕組み:** ファイル名などの「人間向けのラベル」は持ちません。データがバラバラに保存され、OSやデータベースがそれをつなぎ合わせます。
* **例:** PCの内蔵SSD/HDD、AWSのEBS（Elastic Block Store）など。
* **メリット:** * **爆速:** 必要なブロックだけをピンポイントで読み書きできるため、レイテンシ（遅延）が極めて小さい。
* **柔軟:** データベースのような、頻繁に中身が書き換わる用途に最適。


* **デメリット:** 高価。また、ネットワーク越しに複数のPCから同時に読み書きするのが苦手。

## 2. ファイルストレージ (File Storage)

データを「ファイル」という単位でまとめ、フォルダ（ディレクトリ）による階層構造で管理する方式です。

* **仕組み:** 私たちが普段PCで使っている「デスクトップ > 仕事 > 企画書.docx」という管理方法そのものです。名前、作成日、サイズなどの「メタデータ」をセットで保持します。
* **例:** 会社の共有サーバ、NAS（Network Attached Storage）、AWSのEFS（Elastic File System）など。
* **メリット:** * **直感的:** 人間にとって分かりやすく、共有しやすい。
* **共有:** 複数のユーザーやサーバーから同時にアクセスして、ファイルをやり取りするのが得意。


* **デメリット:** ファイル数が増えすぎると、目当てのファイルを探す（パスを辿る）のに時間がかかり、パフォーマンスが落ちる。

---

### 比較まとめ

| 比較項目 | ブロックストレージ | ファイルストレージ |
| --- | --- | --- |
| **データの単位** | 決まったサイズの「塊（ブロック）」 | 階層構造の「ファイル」 |
| **主な利用者** | **アプリケーション、データベース** | **人間、共有サーバー** |
| **アクセス速度** | 非常に高速 | 高速だが、階層が深いと遅くなる |
| **メタデータ** | 最小限（アドレスのみ） | 豊富（名前、権限、日付など） |
| **主な用途** | DB、仮想マシンの起動ディスク | 文書共有、ログ保存、Webコンテンツ |

---

## どう使い分ける？

データエンジニアリングの現場では、以下のように使い分けるのが定石です。

1. **「とにかくスピード重視！DBのクエリを1ミリ秒でも速くしたい！」**
→ **ブロックストレージ**（例：AWS EBSのIOPS最適化など）を選びます。
2. **「複数のサーバーから同じ設定ファイルやログを参照したい！」**
→ **ファイルストレージ**（例：NFSマウント、AWS EFSなど）を選びます。

